aspect ConstraintVariable {  

  public Integer Program.varCount = 0;

  public Map<Integer,ASTNode> Program.varMap = new HashMap();

  public Integer Program.getVarNum(ASTNode node) {
    Integer count = varCount++;
    varMap.put(count, node);
    return count;
  }

  syn lazy Integer Expr.varNum() = program().getVarNum(this);

  eq Access.varNum() {
    if (parent instanceof VersionTypeAccess) {
      return ((VersionTypeAccess) parent).varNum();
    }
    if (parent instanceof ParVersionTypeAccess) {
      return ((ParVersionTypeAccess) parent).varNum();
    }
    return program().getVarNum(this);
  }

  eq ClassInstanceExpr.varNum() = getAccess().varNum();

  eq Dot.varNum() = lastAccess().varNum();

  eq VarAccess.varNum() = decl().varNum();  // TODO: handle multiple possibilities!

  eq VersionTypeAccess.varNum() = getVersionArgument().varNum();

  eq VersionVarArgument.varNum() = decl().varNum();

  eq VersionNumArgument.varNum() = program().getVarNum(this);

  syn lazy Integer Variable.varNum();

  eq ParameterDeclaration.varNum() = getTypeAccess().varNum();

  eq Declarator.varNum() = declarationType().varNum();

  eq EnumConstant.varNum() = program().getVarNum(this);

  eq CatchParameterDeclaration.varNum() = program().getVarNum(this);
  
  eq InferredParameterDeclaration.varNum() = program().getVarNum(this);

  public String Expr.var() {
    return varNum().toString();
  }

  public IntExpr Expr.solverConst;

  coll LinkedList<Object> Program.initConst() root Program;

  // TODO: only generate the necessary variables
  Access contributes each initConst() to Program.initConst();

  syn Collection<Object> Access.initConst() {
    Context ctx = context();
    solverConst = ctx.mkIntConst(var());
    return Collections.emptyList();
  }

  coll HashSet<IntExpr> TypeDecl.getTerms() root TypeDecl;

  Access contributes each getTerm() to TypeDecl.getTerms();

  syn Collection<IntExpr> Access.getTerm() {
    return Collections.singleton(solverConst);
  }

}

aspect ConstraintGeneration {

  // TODO: no subtyping for now!
  coll LinkedList<Formula> TypeDecl.constraint() root TypeDecl;

  Expr contributes each constraintList() to TypeDecl.constraint();

  syn Collection<Formula> Expr.constraintList() = constraint().toList();

  syn Formula Expr.constraint() = new Formula();

  eq ThisAccess.constraint() = new Formula(new Clause(new Lit(solverConst, type().typeNum())));

  eq TypeAccess.constraint() {
    Formula f = new Formula();
    for (TypeDecl type: typeSet()) {
      f.add(clause(type));
    }
    return f;
  }

  eq AssignExpr.constraint() {
    Formula f = new Formula();
    for (TypeDecl source: getSource().typeSet()) {
      for (TypeDecl dest: getDest().typeSet()) {
        if (source == dest) {
          Clause c = new Clause();
          c.add(getSource().clause(source));
          c.add(getDest().clause(dest));
          f.add(c);
        }
      }
    }
    return f;
  }

  eq MethodAccess.constraint() {
    Formula f = new Formula();
    Map<TypeDecl, Collection<MethodDecl>> map = verLookupMethod(name());
    for (TypeDecl qualifierType: map.keySet()) {
      Lit lQualifier = new Lit(qualifier().solverConst, qualifierType.typeNum());
      for (MethodDecl method: map.get(qualifierType)) {
        Formula s = new Formula();

        // TODO: check inheritance

        // TODO: check arguments
        
        // return type constraint
        for (TypeDecl returnType: method.getTypeAccess().typeSet()) {
          // TODO: constraint on the method (depends on condition)

          // constraint on the access itself
          Lit lReturn = new Lit(solverConst, returnType.typeNum());
          s.add(new Clause(lReturn));
        }
        s.multiply(new Clause(lQualifier));
        f.add(s);
      }
    }
    // System.err.println(f);
    return f;
  }

  eq ClassInstanceExpr.constraint() {
    Formula f = new Formula();
    // get the type set of the instantiated class
    for (TypeDecl type: typeSet()) {
      Formula s = new Formula();
      Map<String,VersionArgument> verMap = getAccess().verMap(type);
      for (ConstructorDecl constructor: type.constructors()) {
        Clause c = new Clause();
        for (int i = 0; i < getNumArg(); i++) {
          // TODO: type checking arguments
          SimpleSet<TypeDecl> set 
            = constructor.getParameter(i).getTypeAccess().map(verMap);
          if (set.isSingleton()) {
            c.add(new Lit(getArg(i).solverConst, set.singletonValue().typeNum()));
          }
        }
        s.add(c);
      } 
      Lit lAccess = new Lit(getAccess().solverConst, type.typeNum());
      s.multiply(new Clause(lAccess));
      f.add(s);
    }
    return f;
  }

}