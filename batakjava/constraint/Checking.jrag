aspect VersionChecking {

  coll LinkedList<Problem> TypeDecl.check() root TypeDecl;

  ParVersionTypeAccess contributes each check() to TypeDecl.check();

  syn Collection<Problem> ParVersionTypeAccess.check() {
    if (!hasVersionNumArgument()) {
      return Collections.emptyList();
    }

    for (TypeDecl t: typeSet()) {
      if (t.numComponent() < numComponent()) {
        for (Model m: t.models()) {
          if (applicable(t, m)) {
            return Collections.emptyList();
          }
        }
      }
    }

    return Collections.singletonList(errorf("no applicable solution for %s", prettyPrint()));
  }

  public boolean VersionArgument.check(VersionVariable v, Model m) {
    return true;
  }

  ClassInstanceExpr contributes each check() to TypeDecl.check();

  syn Collection<Problem> ClassInstanceExpr.check() {
    Collection<Problem> err = new LinkedList();

    // check constructor applicability
    boolean applicable = false;
    Iterator<TypeDecl> typeIterator = typeSet().iterator();
    while (typeIterator.hasNext() && !applicable) {
      TypeDecl type = typeIterator.next();
      for (ConstructorDecl constructor: type.constructors()) {
        if (verApplicableAndAccessible(constructor).isPresent()) {
          applicable = true;
          break;
        }
      }
    }
    if (!applicable) {
      err.add(errorf("no applicable constructor for %s", prettyPrint()));
    }

    return err;
  }

  MethodAccess contributes each check() to TypeDecl.check();

  syn Collection<Problem> MethodAccess.check() {
    Map<TypeDecl,Collection<MethodDecl>> map = verLookupMethod(name());
    if (map.size() == 0) {
      return Collections.<Problem>singletonList(
        errorf("no applicable method for %s", prettyPrint()));
    }

    // TODO: make an example for this
    boolean applicable = false;
    Iterator<TypeDecl> typeIterator = map.keySet().iterator();
    while (typeIterator.hasNext() && !applicable) {
      TypeDecl type = typeIterator.next();
      for (MethodDecl m: map.get(type)) {
        if (verApplicableAndAccessible(m).isPresent()) {
          applicable = true;
          break;
        }
      }
    }
    if (!applicable) {
      return Collections.<Problem>singletonList(
        errorf("no applicable method for %s", prettyPrint()));
    }

    return Collections.emptyList();
  }

  public boolean ParVersionTypeAccess.applicable(TypeDecl t, Model m) {
    Iterator<VersionVariable> iterator = t.versionVariableList().iterator();
    int i = 0;
    while (iterator.hasNext()) {
      VersionVariable v = iterator.next();
      VersionArgument a = getVersionArgument(i);
      if (a.isVersionNumArgument()) {
        TypeAccess access = v.typeAccess();
        TypeDecl modelType = access.getType(m);
        if (!modelType.version().equals(a.version())) {
          return false;
        }
      }
      i++;
    }
    return true;
  }

}