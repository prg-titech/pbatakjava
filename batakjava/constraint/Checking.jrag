aspect VersionChecking {

  public Model ParVersionTypeAccess.solution;

  coll LinkedList<Problem> TypeDecl.check() root TypeDecl;

  ParVersionTypeAccess contributes each check() to TypeDecl.check();

  // TODO: fix this, handle version var argument
  syn Collection<Problem> ParVersionTypeAccess.check() {
    return Collections.emptyList();
  }

  /*
  syn Collection<Problem> ParVersionTypeAccess.check() {
    // get type set of the instantiated class
    SimpleSet<TypeDecl> typeSet = typeSet();
    for (TypeDecl type: typeSet()) {
      if (!(type instanceof GenericVersionClassDecl)) {
        throw new Error("Version arguments can't be passed to a "
            + "non-generic class declaration.");
      }
      GenericVersionClassDecl t = (GenericVersionClassDecl) type;
      if (t.getNumVersionVariable() != getNumVersionArgument()) {
        throw new Error("Number of version parameters and arguments "
            + "do not match in " + prettyPrint());
      }
      // get a model for that type
      java.util.List<Model> models = t.models();
      for (Model model: models) {
        int i;
        // get the type's parameters and check against arguments
        for (i = 0; i < t.getNumVersionVariable(); i++) {
          VersionVariable v = t.getVersionVariable(i);
          VersionArgument a = getVersionArgument(i);
          if (!a.check(v, model)) {
            break;
          }
        }
        if (i == t.getNumVersionVariable()) {
          // attaches solution to the expression
          solution = model;
        }
      }
    }
    if (solution == null) {
      throw new Error(prettyPrint() + " does not match any solution.");
    }
    return Collections.emptyList();
  }
  */

  public boolean VersionArgument.check(VersionVariable v, Model m) {
    return true;
  }

  ClassInstanceExpr contributes each check() to TypeDecl.check();

  syn Collection<Problem> ClassInstanceExpr.check() {
    Collection<Problem> err = new LinkedList();

    // check constructor applicability
    boolean applicable = false;
    Iterator<TypeDecl> typeIterator = typeSet().iterator();
    while (typeIterator.hasNext() && !applicable) {
      TypeDecl type = typeIterator.next();
      for (ConstructorDecl constructor: type.constructors()) {
        if (verApplicableAndAccessible(constructor).isPresent()) {
          applicable = true;
          break;
        }
      }
    }
    if (!applicable) {
      err.add(errorf("no applicable constructor for %s", prettyPrint()));
    }

    return err;
  }

  MethodAccess contributes each check() to TypeDecl.check();

  syn Collection<Problem> MethodAccess.check() {
    Map<TypeDecl,Collection<MethodDecl>> map = verLookupMethod(name());
    if (map.size() == 0) {
      return Collections.<Problem>singletonList(
        errorf("no applicable method for %s", prettyPrint()));
    }

    // TODO: make an example for this
    boolean applicable = false;
    Iterator<TypeDecl> typeIterator = map.keySet().iterator();
    while (typeIterator.hasNext() && !applicable) {
      TypeDecl type = typeIterator.next();
      for (MethodDecl m: map.get(type)) {
        if (verApplicableAndAccessible(m).isPresent()) {
          applicable = true;
          break;
        }
      }
    }
    if (!applicable) {
      return Collections.<Problem>singletonList(
        errorf("no applicable method for %s", prettyPrint()));
    }

    return Collections.emptyList();
  }

  /*
  public boolean VersionNumArgument.check(VersionVariable v, Model m) {
    TypeDecl vType = getType(
        new Integer(m.evaluate(v.solverConst, false).toString()));
    return vType.version().equals(version());
  }
  */

}