import com.microsoft.z3.Context;
import com.microsoft.z3.Solver;
import com.microsoft.z3.Status;
import com.microsoft.z3.Model;

aspect ConstraintSolving {

  public java.util.List<Context> Program.contexts;

  public Context Expr.context() { return program().contexts.get(numComponent()); }

  public java.util.List<java.util.List<Model>> Program.componentSolutionLists;

  public java.util.List<Model> Program.currentSolutionList;

  public void Program.blockTerm(Context c, Solver s, Model m, IntExpr t) {
    Integer eval = new Integer(m.evaluate(t, false).toString());
    s.add(c.mkNot(c.mkEq(t, c.mkInt(eval))));
  }

  public void Program.fixTerm(Context c, Solver s, Model m, IntExpr t) {
    Integer eval = new Integer(m.evaluate(t, false).toString());
    s.add(c.mkEq(t, c.mkInt(eval)));
  }

  public void Program.getAllSolutions(Solver s, int i) {
    Context c = contexts.get(i);
    if (s.check() == Status.SATISFIABLE) {
      Model m = s.getModel();
      currentSolutionList.add(m);
      java.util.List<IntExpr> terms = getTerms(i);
      for (int j = 0; j < terms.size(); j++) {
        s.push();
        IntExpr tb = terms.get(j);
        blockTerm(c, s, m, tb);
        for (int k = 0; k < j; k++) {
          IntExpr tf = terms.get(k); 
          fixTerm(c, s, m, tf);
        }
        getAllSolutions(s, i);
        s.pop();
      }
    }
  }

  public java.util.List<IntExpr> Program.getTerms(int i) {
    java.util.List<IntExpr> terms = new ArrayList();
    for (TypeDecl type: getComponent(i)) {
      terms.addAll(type.getTerms());
    }
    return terms;
  }

  public int Program.solve(int i) {
    Context ctx = contexts.get(i);
    Solver s = ctx.mkSolver();

    // Gather initial constraints
    for (TypeDecl t: getComponent(i)) {
      System.err.println(t.prettyPrint());
      for (Formula f: t.constraint()) {
        s.add(f.convert(ctx));
      } 
    }

    // Get all the solutions
    currentSolutionList = new ArrayList();
    getAllSolutions(s, i);
    if (currentSolutionList.size() == 0) {
      throw new Error("No solution found component " + i);
    }
    componentSolutionLists.add(currentSolutionList);

    return 0;
  }

  public int Program.solve() {
    // Setting up dependency graph
    initializeGraph();

    contexts = new ArrayList(numComponent());
    componentSolutionLists = new ArrayList(numComponent());

    // Create a context for each component
    for (int i=0; i<numComponent(); i++) {
      HashMap<String,String> cfg = new HashMap<String,String>();
      cfg.put("model", "true");
      Context ctx = new Context(cfg);
      contexts.add(ctx);
    }

    // Initialize solver constant
    initConst();

    for (int i=0; i<numComponent(); i++) {
      if (getTerms(i).size() == 0) {
        componentSolutionLists.add(new ArrayList());
        continue;
      }
      solve(i);
    }

    // System.err.println(printTypeMap());

    return 0;
  }

}