aspect LookupMethod {

  // TODO: different version of superclass
  inh Map<TypeDecl,Collection<MethodDecl>> Expr.verLookupMethod(String name);

  eq Program.getChild().verLookupMethod(String name) = new HashMap();
  
  eq Dot.getRight().verLookupMethod(String name) {
    Map<TypeDecl,Collection<MethodDecl>> map = new HashMap();
    for (TypeDecl type: getLeft().typeSet()) {
      map.put(type, type.memberMethods(name));
    }
    return map;
  }

}

aspect MethodDecl {

  syn Optional<Formula> MethodAccess.verApplicableAndAccessible(MethodDecl m) {
    if (m.getNumParameter() != getNumArg()) {
      return Optional.empty();
    }

    if (!accessible(m)) {
      return Optional.empty();
    }

    Formula f = new Formula();
    for (int i = 0; i < m.getNumParameter(); i++) {
      Optional<Formula> fArg = getArg(i).subtype(m.getParameter(i).getTypeAccess());
      if (fArg.isPresent()) {
        f = f.multiply(fArg.get());
      } else {
        return Optional.empty();
      }
    }
    
    return Optional.of(f);
  }

  eq ParVersionMethodAccess.verApplicableAndAccessible(MethodDecl m) {
    if (m.numVersionVariable() != getNumVersionArgument()) {
      return Optional.empty();
    }
    
    return super.verApplicableAndAccessible(m);
  }

}

aspect MemberMethods {

  syn java.util.List<MethodDecl> TypeDecl.eagerLocalMethods() {
    if (getNumBodyDecl() == 0) {
      return Collections.emptyList();
    }
    ArrayList<MethodDecl> methods = new ArrayList<MethodDecl>(getNumBodyDecl());
    for (BodyDecl decl : getBodyDeclList()) {
      if (decl instanceof MethodDecl) {
        methods.add((MethodDecl) decl);
      }
    }
    return methods;
  }

}