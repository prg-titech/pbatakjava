aspect Generation {

  public java.util.List<String> Program.generatedNames = new ArrayList();

  public Program Program.compile() {
    Program generated = new Program();
    generated.state().reset();

    SimpleSet<String> interfaceNames = emptySet();

    for (int i = 0; i < numComponent(); i++) {
      // TODO: handling multiple solutions
      java.util.List<Model> componentModels = getComponentModels(i);
      Model componentModel = getTerms(i).size() == 0 ? null : componentModels.get(0);

      for (TypeDecl t: getComponent(i)) {
        String name = t.packageName() + "." + t.name();

        CompilationUnit unit = t.compilationUnit();
        unit.model = componentModel;

        // generating interface
        List<TypeDecl> is = t.compileInterface();

        if (interfaceNames.contains(name)) {
          TypeDecl newInterface = is.iterator().next();
          TypeDecl oldInterface = generated.findInterface(newInterface.packageName(), newInterface.name());
          for (BodyDecl newBody: newInterface.getBodyDeclList()) {
            oldInterface.addBodyDecl(newBody);
            BodyDecl newBodyWithReturn = newBody.addReturnStmt();
            SimpleSet<TypeDecl> existingClassSet
              = generated.findClassSet(newInterface.packageName(), newInterface.name());
            for (TypeDecl existingClass: existingClassSet) {
              existingClass.addBodyDecl(newBodyWithReturn);
            }
          }
        } else {
          CompilationUnit interfaceUnit = unit.compile(is);
          CompilationUnit factoryUnit = unit.compile(t.compileInterfaceFactory());

          generated.addNewCompilationUnit(interfaceUnit);
          generated.addNewCompilationUnit(factoryUnit);

          interfaceNames = interfaceNames.add(name);
        }

        // generating class and factory
        List<TypeDecl> cs = t.compileClass();
        
        CompilationUnit classUnit = unit.compile(cs);
        generated.addNewCompilationUnit(classUnit);
      }
    }

    return generated;
  }

  syn nta CompilationUnit CompilationUnit.compile(List<TypeDecl> typeList) {
    CompilationUnit unit = new CompilationUnit(getPackageDecl(), new List(), typeList);
    unit.setFromSource(true);
    unit.setClassSource(getClassSource());
    return unit;
  }
  
  syn nta List<TypeDecl> TypeDecl.compileInterface() = new List();

  // TODO: handle different constructors in different versions
  eq VersionClassDecl.compileInterface() {
    List<TypeDecl> types = new List();
    List<BodyDecl> bodyList = new List();
    
    for (BodyDecl body: getBodyDeclList()) {
      bodyList = bodyList.addAll(body.compileInterface());

    }
    return new List().add(new InterfaceDecl(
      new Modifiers(new List().add(new Modifier("public"))),
      getID(),
      new List(),
      bodyList));
  }

  syn nta List<TypeDecl> TypeDecl.compileInterfaceFactory() = new List();

  eq VersionClassDecl.compileInterfaceFactory() {
    List<BodyDecl> factoryBodyList = new List();

    for (BodyDecl body: getBodyDeclList()) {
      factoryBodyList = factoryBodyList.addAll(body.compileInterfaceFactory());
    }

    return new List().add(new InterfaceDecl(
      new Modifiers(new List().add(new Modifier("public"))),
      getID() + "_Factory",
      new List(),
      factoryBodyList));
  }

  syn nta List<TypeDecl> TypeDecl.compileClass() = new List().add(treeCopy());

  eq ClassDecl.compileClass() {
    List<TypeDecl> types = new List();
    List<BodyDecl> bodyList = new List();

    for (BodyDecl body: getBodyDeclList()) {
      bodyList = bodyList.add(body.compile());
    }

    Opt<Access> superAccess = hasSuperClass() ? new Opt(getSuperClass().compileAccess()) : new Opt();

    types = types.add(new ClassDecl(
      getModifiers(),
      getID(),
      superAccess,
      new List(),
      bodyList));

    return types;
  }

  eq VersionClassDecl.compileClass() {
    List<TypeDecl> types = new List();
    List<BodyDecl> bodyList = new List();
    List<BodyDecl> factoryBodyList = new List();

    if (this instanceof GenericVersionClassDecl) {
      GenericVersionClassDecl thisType = (GenericVersionClassDecl) this;
      for (VersionVariable v: thisType.getVersionVariableList()) {
        TypeAccess typeAccess = v.typeAccess();
        TypeDecl type = typeAccess.compileType();
        List<FieldDeclarator> decls = new List().add(new FieldDeclarator(
          v.getID(), new List(), new Opt()));
        bodyList = bodyList.add(new FieldDecl(
          new Modifiers(new List().add(new Modifier("public"))),
          new TypeAccess(type.packageName(), type.name() + "_Factory"),
          decls
        ));
      }
    }

    for (BodyDecl body: getBodyDeclList()) {
      bodyList = bodyList.add(body.compile());
      factoryBodyList = factoryBodyList.addAll(body.compileFactory());
    }

    types = types.add(new ClassDecl(
      getModifiers(),
      getID() + "_v" + version(), 
      new Opt(),
      new List().add(new TypeAccess(packageName(), getID())),
      bodyList));

    types = types.add(new ClassDecl(
      new Modifiers(new List().add(new Modifier("public"))),
      getID() + "_v" + version() + "_Factory",
      new Opt(),
      new List().add(new TypeAccess(packageName(), getID() + "_Factory")),
      factoryBodyList));

    return types;
  }

  syn nta BodyDecl BodyDecl.compile() = treeCopy();

  eq ConstructorDecl.compile() {
    List<ParameterDeclaration> params = new List();
    List<Stmt> blockStmtList = new List();

    // TODO: get rid of instanceof from here
    if (hostType() instanceof GenericVersionClassDecl) {
      GenericVersionClassDecl host = (GenericVersionClassDecl) hostType();
      for (int i = 0; i < host.getNumVersionVariable(); i++) {
        VersionVariable v_i = host.getVersionVariable(i);
        TypeAccess typeAccess_i = v_i.typeAccess();
        TypeDecl type_i = typeAccess_i.compileType();
        params = params.add(new ParameterDeclaration(
          new Modifiers(),
          new TypeAccess(type_i.packageName(), type_i.name() + "_Factory"),
          v_i.getID()
        ));
        blockStmtList = blockStmtList.add(new ExprStmt(
          new AssignSimpleExpr(
            new Dot(
              new ThisAccess(),
              new VarAccess(v_i.getID())
            ),
            new VarAccess(v_i.getID())
          )
        ));
      }
    }

    for (ParameterDeclaration param: getParameterList()) {
      params = params.add(param.compileParameter());
    }

    Opt<Stmt> parsed = hasParsedConstructorInvocation()
      ? new Opt(getParsedConstructorInvocation().compileStmt())
      : new Opt();

    Block newBlock = getBlock().compileBlock();

    for (Stmt stmt: newBlock.getStmtList()) {
      blockStmtList = blockStmtList.add(stmt);
    }

    return new ConstructorDecl(
      getModifiers(),
      ((ClassDecl) hostType()).compileName(),
      params,
      getExceptionList(),
      parsed,
      new Block(blockStmtList));
  }

  eq MethodDecl.compile() {
    List<ParameterDeclaration> params = new List();
    for (ParameterDeclaration param: getParameterList()) {
      params = params.add(param.compileParameter());
    }

    return new MethodDecl(
      getModifiers(),
      getTypeAccess().compileAccess(),
      getID(),
      params,
      new List(),
      hasBlock() ? new Opt(getBlock().compileBlock()) : new Opt());
  }

  eq GenericVersionMethodDecl.compile() {
    List<ParameterDeclaration> params = new List();

    for (VersionVariable v: getVersionVariableList()) {
      TypeAccess typeAccess = v.typeAccess();
      TypeDecl type = typeAccess.compileType();
      params = params.add(new ParameterDeclaration(
        new Modifiers(),
        new TypeAccess(type.packageName(), type.name() + "_Factory"),
        v.getID()
      ));
    }

    for (ParameterDeclaration param: getParameterList()) {
      params = params.add(param.compileParameter());
    }

    return new MethodDecl(
      getModifiers(),
      getTypeAccess().compileAccess(),
      getID(),
      params,
      new List(),
      hasBlock() ? new Opt(getBlock().compileBlock()) : new Opt());
  }

  eq FieldDecl.compile() {
    List<FieldDeclarator> decls = new List();
    for (FieldDeclarator decl: getDeclaratorList()) {
      decls = decls.add(decl.compileDeclarator());
    }
    return new FieldDecl(
      getModifiers(),
      getTypeAccess().compileAccess(),
      decls);
  }

  syn nta List<BodyDecl> BodyDecl.compileInterface() = new List();

  eq GenericVersionMethodDecl.compileInterface() {
    List<ParameterDeclaration> ps = new List();
    
    for (VersionVariable v: getVersionVariableList()) {
      TypeAccess ta = v.typeAccess();
      TypeDecl t = ta.compileType();
      ps = ps.add(new ParameterDeclaration(
        new Modifiers(),
        new TypeAccess(t.packageName(), t.name() + "_Factory"),
        v.getID()));
    }

    for (ParameterDeclaration p: getParameterList()) {
      ps = ps.add(p.compileParameter());
    }

    return new List().add(new MethodDecl(
      getModifiers(),
      getTypeAccess().compileAccess(),
      getID(),
      ps,
      new List(),
      new Opt()));
  }

  syn nta ParameterDeclaration ParameterDeclaration.compileParameter()
    = new ParameterDeclaration(getModifiers(), getTypeAccess().compileAccess(), getID());

  syn nta Access Access.compileAccess() = treeCopy();

  eq Dot.compileAccess() = new Dot(getLeft().compileExpr(), getRight().compileAccess());

  eq TypeAccess.compileAccess() {
    TypeDecl type = program().typeMap.get(
      new Integer(model().evaluate(solverConst, false).toString()));
    if (type.isVersioned()) {
      return new TypeAccess(getPackage(), type.getID() + "_v" + type.version());
    }
    return treeCopy();
  }
  
  eq VersionTypeAccess.compileAccess() {
    if (getVersionArgument() instanceof VersionVarArgument) {
      return getTypeAccess().treeCopy();
    }
    return getTypeAccess().compileAccess();
  }

  eq ParVersionTypeAccess.compileAccess() = getTypeAccess().compileAccess();

  eq ParVersionMethodAccess.compileAccess() {
    TypeDecl qualifierType = isQualified() ? qualifier().compileType() : hostType();
    Map<TypeDecl,Collection<MethodDecl>> methodMap = verLookupMethod(name());
    Collection<MethodDecl> methods = new ArrayList();
    for (TypeDecl keyType: methodMap.keySet()) {
      if (keyType == qualifierType) {
        methods = methodMap.get(keyType);
      }
    }

    List<Expr> argList = new List();

    if (methods.size() == 1) {
      MethodDecl m = methods.iterator().next();
      int i = 0;
      for (VersionVariable vv: m.versionVariableList()) {
        VersionArgument va = getVersionArgument(i);
        TypeAccess compileAccess = vv.typeAccess();
        // TODO: handle version variable argument
        if (va instanceof VersionNumArgument) {
          argList = argList.add(new ClassInstanceExpr(
            new TypeAccess(compileAccess.getPackage(),
                           compileAccess.getID() + "_v" + va.getID() + "_Factory"),
            new List()
          ));
        } else if (va instanceof VersionVarArgument) {
          argList = argList.add(new VarAccess(va.getID()));
        }
        i++;
      }
    }

    for (Expr expr: getArgList()) {
      argList = argList.add(expr.compileExpr());
    }

    return new MethodAccess(getID(), argList);
  }

  syn nta Block Block.compileBlock() {
    List<Stmt> stmtList = new List();
    for (Stmt stmt: getStmtList()) {
      stmtList = stmtList.add(stmt.compileStmt());
    }
    return new Block(stmtList);
  }

  syn nta Stmt Stmt.compileStmt() = treeCopy();

  eq VarDeclStmt.compileStmt() {
    List<VariableDeclarator> decls = new List();
    for (VariableDeclarator decl: getDeclaratorList()) {
      decls = decls.add(decl.compileDeclarator());
    }
    return new VarDeclStmt(
      getModifiers(),
      getTypeAccess().compileAccess(),
      decls);
  }

  eq ReturnStmt.compileStmt() = hasResult() ? new ReturnStmt(getResult().compileExpr()) : new ReturnStmt(new Opt());

  syn nta VariableDeclarator VariableDeclarator.compileDeclarator()
    = new VariableDeclarator(getID(), getDimsList(), hasInit() ? new Opt(getInit().compileExpr()) : new Opt());

  syn nta FieldDeclarator FieldDeclarator.compileDeclarator()
    = new FieldDeclarator(getID(), getDimsList(), hasInit() ? new Opt(getInit().compileExpr()) : new Opt());

  syn nta Expr Expr.compileExpr() = treeCopy();

  eq Access.compileExpr() = compileAccess();

  eq ClassInstanceExpr.compileExpr() {
    List<Expr> argList = new List();
    if (getAccess() instanceof ParVersionTypeAccess) {
      ParVersionTypeAccess typeAccess = (ParVersionTypeAccess) getAccess();

      TypeDecl compileType = program().typeMap.get(new Integer(model().evaluate(getAccess().solverConst, false).toString()));
      assert compileType instanceof GenericVersionClassDecl;
      GenericVersionClassDecl compileClass = (GenericVersionClassDecl) compileType;

      for (int i = 0; i < typeAccess.getNumVersionArgument(); i++) {
        VersionArgument va = typeAccess.getVersionArgument(i);
        VersionVariable vv = compileClass.getVersionVariable(i);
        TypeAccess compileAccess = vv.typeAccess();
        if (va instanceof VersionNumArgument) {
          argList = argList.add(new ClassInstanceExpr(
            new TypeAccess(compileAccess.getPackage(),
                           compileAccess.getID() + "_v" + va.getID() + "_Factory"),
            new List()
          ));
        } else if (va instanceof VersionVarArgument) {
          argList = argList.add(new VarAccess(va.getID()));
        }
      }
    }

    Access access = getAccess().compileAccess();
    for (Expr arg: getArgList()) {
      argList = argList.add(arg.compileExpr());
    }

    if (getAccess() instanceof VersionTypeAccess) {
      VersionTypeAccess typeAccess = (VersionTypeAccess) getAccess();
      VersionArgument va = typeAccess.getVersionArgument();

      Access makeCall = new MethodAccess("make", argList);
      return new Dot(
        new VarAccess(va.getID()),
        makeCall);
    }

    return new ClassInstanceExpr(access, argList);
  }
  
  syn String TypeDecl.compileName() = name();

  eq VersionClassDecl.compileName() = getID() + "_v" + version();

  public TypeDecl Expr.compileType() {
    return program().typeMap.get(new Integer(model().evaluate(solverConst, false).toString()));
  }

  syn nta List<BodyDecl> BodyDecl.compileFactory() = new List();

  eq ConstructorDecl.compileFactory() {
    List<ParameterDeclaration> params = new List();
    List<Expr> argList = new List();

    if (hostType() instanceof GenericVersionClassDecl) {
      GenericVersionClassDecl host = (GenericVersionClassDecl) hostType();
      for (int i = 0; i < host.getNumVersionVariable(); i++) {
        VersionVariable v_i = host.getVersionVariable(i);
        TypeAccess typeAccess_i = v_i.typeAccess();
        TypeDecl type_i = typeAccess_i.compileType();
        params = params.add(new ParameterDeclaration(
          new Modifiers(),
          new TypeAccess(type_i.packageName(), type_i.name() + "_Factory"),
          v_i.getID()
        ));
        argList = argList.add(new VarAccess(v_i.getID()));
      }
    }

    for (ParameterDeclaration param: getParameterList()) {
      params = params.add(param.compileParameter());
      argList = argList.add(new VarAccess(param.getID()));
    }
    
    List<Stmt> stmtList = new List().add(new ReturnStmt(
      new Opt(new ClassInstanceExpr(
        new TypeAccess(hostType().packageName(), hostType().compileName()),
        argList,
        new Opt()
      ))
    ));

    return new List().add(new MethodDecl(
      new Modifiers(new List().add(new Modifier("public"))),
      new TypeAccess(hostType().packageName(), hostType().name()),
      "make",
      params,
      new List(),
      new Opt(new Block(stmtList))
    ));
  }

  syn nta List<BodyDecl> BodyDecl.compileInterfaceFactory() = new List();

  eq ConstructorDecl.compileInterfaceFactory() {
    List<ParameterDeclaration> params = new List();

    if (hostType() instanceof GenericVersionClassDecl) {
      GenericVersionClassDecl host = (GenericVersionClassDecl) hostType();
      for (int i = 0; i < host.getNumVersionVariable(); i++) {
        VersionVariable v_i = host.getVersionVariable(i);
        TypeAccess typeAccess_i = v_i.typeAccess();
        TypeDecl type_i = typeAccess_i.compileType();
        params = params.add(new ParameterDeclaration(
          new Modifiers(),
          new TypeAccess(type_i.packageName(), type_i.name() + "_Factory"),
          v_i.getID()
        ));
      }
    }

    for (ParameterDeclaration param: getParameterList()) {
      params = params.add(param.compileParameter());
    }

    return new List().add(new MethodDecl(
      new Modifiers(new List().add(new Modifier("public"))),
      new TypeAccess(hostType().packageName(), hostType().name()),
      "make",
      params,
      new List(),
      new Opt())
    );
  }

  syn nta BodyDecl BodyDecl.addReturnStmt() = treeCopy();

  eq MethodDecl.addReturnStmt() {
    List<ParameterDeclaration> ps = new List();

    for (ParameterDeclaration p: getParameterList()) {
      ps = ps.add(p.treeCopy());
    }

    List<Stmt> stmtList = new List().add(new ReturnStmt(new NullLiteral("null")));

    return new MethodDecl(
      getModifiers(),
      getTypeAccess().treeCopy(),
      getID(),
      ps,
      new List(),
      new Opt(new Block(stmtList)));
  }
}