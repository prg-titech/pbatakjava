aspect Generation {

  public java.util.List<String> Program.newTypes = new ArrayList();

  public Program Program.compile() {
    Program generated = new Program();
    generated.state().reset();

    for (int i = 0; i < numComponent(); i++) {
      // TODO: handling multiple solutions
      java.util.List<Model> componentModels = getComponentModels(i);
      assert componentModels.size() > 0;
      Model componentModel = componentModels.get(0);
      for (TypeDecl type: getComponent(i)) {
        CompilationUnit unit = type.compilationUnit();
        unit.model = componentModel;
        CompilationUnit newUnit = unit.compile();
        generated.addNewCompilationUnit(newUnit);
      }
    }

    return generated;
  }

  syn nta CompilationUnit CompilationUnit.compile() {
    List<TypeDecl> types = new List();
    for (TypeDecl type: getTypeDeclList()) {
      for (TypeDecl newType: type.compile()) {
        String newTypeName = packageName() + "." + newType.name();
        if (!program().newTypes.contains(newTypeName)) {
          program().newTypes.add(newTypeName);
          types = types.add(newType);
        }
      }
    }

    CompilationUnit unit = new CompilationUnit(getPackageDecl(), new List(), types);
    unit.setFromSource(true);
    unit.setClassSource(getClassSource());

    return unit;
  }

  syn nta List<TypeDecl> TypeDecl.compile() = new List().add(treeCopy());

  eq VersionClassDecl.compile() {
    List<TypeDecl> types = new List();

    types = types.addAll(compileInterface());
    types = types.addAll(compileClass());

    return types;
  }

  syn nta List<TypeDecl> VersionClassDecl.compileInterface() {
    List<TypeDecl> types = new List();

    // build interface for class
    TypeDecl classInterface = new InterfaceDecl(
      new Modifiers(new List().add(new Modifier("public"))),
      getID(),
      new List(),
      new List()
    );
    types = types.add(classInterface);
    
    // build interface for factory
    TypeDecl factoryInterface = new InterfaceDecl(
      new Modifiers(new List().add(new Modifier("public"))),
      getID() + "_Factory",
      new List(),
      new List()
    );
    types = types.add(factoryInterface);

    return types;
  }

  syn nta List<TypeDecl> VersionClassDecl.compileClass() {
    List<TypeDecl> types = new List();

    List<BodyDecl> bodyList = new List();
    for (BodyDecl body: getBodyDeclList()) {
      bodyList = bodyList.add(body.compile());
    }

    TypeDecl classClass = new ClassDecl(
      getModifiers(),
      getID() + "_v" + version(), 
      new Opt(),
      new List().add(new TypeAccess(packageName(), getID())),
      bodyList
    );
    types = types.add(classClass);

    TypeDecl factoryClass = new ClassDecl(
      new Modifiers(new List().add(new Modifier("public"))),
      getID() + "_v" + version() + "_Factory",
      new Opt(),
      new List().add(new TypeAccess(packageName(), getID() + "_Factory")),
      new List()
    );
    types = types.add(factoryClass);

    return types;
  }

  syn nta BodyDecl BodyDecl.compile() = treeCopy();

  eq ConstructorDecl.compile() {
    List<ParameterDeclaration> params = new List();
    for (ParameterDeclaration param: getParameterList()) {
      params = params.add(param.compileParameter());
    }

    Opt<Stmt> parsed = hasParsedConstructorInvocation()
      ? new Opt(getParsedConstructorInvocation().compileStmt())
      : new Opt();

    return new ConstructorDecl(
      getModifiers(),
      ((ClassDecl) hostType()).compileName(),
      params,
      getExceptionList(),
      parsed,
      getBlock().compileBlock()
    );
  }

  eq MethodDecl.compile() {
    List<ParameterDeclaration> params = new List();
    for (ParameterDeclaration param: getParameterList()) {
      params = params.add(param.compileParameter());
    }

    return new MethodDecl(
      getModifiers(),
      getTypeAccess().compileAccess(),
      getID(),
      params,
      new List(),
      hasBlock() ? new Opt(getBlock().compileBlock()) : new Opt()
    );
  }

  syn nta ParameterDeclaration ParameterDeclaration.compileParameter() = treeCopy();

  syn nta Access Access.compileAccess() = treeCopy();

  eq TypeAccess.compileAccess() {
    TypeDecl type = program().typeMap.get(
      new Integer(model().evaluate(solverConst, false).toString()));
    if (type.isVersioned()) {
      return new TypeAccess(getPackage(), type.getID() + "_v" + type.version());
    }
    return treeCopy();
  }

  syn nta Block Block.compileBlock() {
    List<Stmt> stmtList = new List();
    for (Stmt stmt: getStmtList()) {
      stmtList = stmtList.add(stmt.compileStmt());
    }
    return new Block(stmtList);
  }

  syn nta Stmt Stmt.compileStmt() = treeCopy();

  eq VarDeclStmt.compileStmt() {
    List<VariableDeclarator> decls = new List();
    for (VariableDeclarator decl: getDeclaratorList()) {
      decls = decls.add(decl.compileDeclarator());
    }
    return new VarDeclStmt(
      getModifiers(),
      getTypeAccess().compileAccess(),
      decls
    );
  }

  syn nta VariableDeclarator VariableDeclarator.compileDeclarator()
    = new VariableDeclarator(getID(), getDimsList(), hasInit() ? new Opt(getInit().compileExpr()) : new Opt());

  syn nta Expr Expr.compileExpr() = treeCopy();

  eq ClassInstanceExpr.compileExpr() {
    Access access = getAccess().compileAccess();
    List<Expr> argList = new List();
    for (Expr arg: getArgList()) {
      argList = argList.add(arg.compileExpr());
    }
    return new ClassInstanceExpr(access, argList);
  }

  syn String TypeDecl.compileName() = name();

  eq VersionClassDecl.compileName() = getID() + "_v" + version();
}